<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XelCore • Mark XII — Singularity Collapse</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils"></script>
    <style>
        :root { --cyan: #00f3ff; --magenta: #ff00ff; --red: #ff3c00; --bg: #000002; }
        body { margin: 0; overflow: hidden; background: var(--bg); font-family: 'Orbitron', 'Segoe UI', sans-serif; cursor: none; color: white; }
        
        #hud-top {
            position: absolute; top: 0; width: 100%; padding: 30px 50px;
            display: flex; justify-content: space-between; z-index: 10;
            pointer-events: none; box-sizing: border-box;
        }

        .glass-panel {
            background: rgba(0, 243, 255, 0.05);
            border-left: 4px solid var(--cyan);
            padding: 15px 25px;
            backdrop-filter: blur(5px);
            text-transform: uppercase;
            letter-spacing: 3px;
        }

        .stat-value { font-size: 1.8rem; font-weight: 900; color: var(--cyan); text-shadow: 0 0 15px var(--cyan); }
        .stat-label { font-size: 0.7rem; opacity: 0.7; display: block; }

        #reticle {
            position: absolute; width: 50px; height: 50px;
            border: 1px solid var(--cyan); transform: translate(-50%, -50%);
            pointer-events: none; z-index: 100;
            display: flex; align-items: center; justify-content: center;
            transition: all 0.1s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        #reticle::before, #reticle::after {
            content: ''; position: absolute; width: 10px; height: 10px; border: 1px solid var(--cyan);
        }
        #reticle::before { top: -5px; left: -5px; border-right: none; border-bottom: none; }
        #reticle::after { bottom: -5px; right: -5px; border-left: none; border-top: none; }
        
        #reticle.fist { width: 70px; height: 70px; border-color: var(--red); box-shadow: 0 0 30px var(--red); }
        #reticle.fist::before, #reticle.fist::after { border-color: var(--red); }

        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 200; background: rgba(0,0,0,0.9); transition: opacity 0.5s;
        }

        .btn-core {
            background: none; border: 2px solid var(--cyan); color: var(--cyan);
            padding: 20px 50px; font-size: 1.5rem; font-weight: 900;
            cursor: pointer; text-transform: uppercase; letter-spacing: 5px;
            margin-top: 30px; transition: all 0.3s;
        }
        .btn-core:hover { background: var(--cyan); color: black; box-shadow: 0 0 50px var(--cyan); }

        #combo-msg {
            position: absolute; bottom: 15%; left: 50%; transform: translateX(-50%);
            font-size: 4rem; font-weight: 900; color: var(--magenta);
            text-shadow: 0 0 20px var(--magenta); pointer-events: none;
            opacity: 0; transition: opacity 0.2s;
        }

        #video-preview {
            position: absolute; bottom: 30px; left: 30px; width: 160px;
            border: 1px solid var(--cyan); opacity: 0.4; transform: scaleX(-1);
            border-radius: 10px; overflow: hidden;
        }
        video { width: 100%; }
    </style>
</head>
<body>

<div id="hud-top">
    <div class="glass-panel">
        <span class="stat-label">Sector Signal</span>
        <span class="stat-value" id="score">00000</span>
    </div>
    <div class="glass-panel" style="text-align: right; border-left: none; border-right: 4px solid var(--cyan); padding-left: 0; padding-right: 25px;">
        <span class="stat-label">Core Stability</span>
        <span class="stat-value" id="health">100%</span>
    </div>
</div>

<div id="reticle"></div>
<div id="combo-msg">MAX OVERDRIVE</div>

<div id="overlay">
    <h1 style="font-size: 4rem; letter-spacing: 15px; margin: 0; color: var(--cyan);">XELCORE MK-XII</h1>
    <p style="letter-spacing: 5px; opacity: 0.6;">SINGULARITY COLLAPSE PROTOCOL</p>
    <div style="max-width: 500px; text-align: center; font-size: 0.9rem; margin-top: 20px; line-height: 1.6; opacity: 0.8;">
        Control táctico detectado. <br>
        Palma abierta para navegar la singularidad. <br>
        Pulso de puño para fragmentar anomalías.
    </div>
    <button class="btn-core" id="init-btn">ESTABLECER VÍNCULO</button>
</div>

<div id="video-preview"><video id="input_video"></video></div>
<canvas id="stage"></canvas>

<script>
    /** XELCORE MK-XII: SINGULARITY COLLAPSE - ENGINE **/
    
    let active = false;
    let stats = { score: 0, health: 100, level: 1, combo: 0 };
    const config = { speed: 0.8, spawnRate: 0.04 };

    // --- THREE.JS: NÚCLEO GRÁFICO ---
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000002, 0.015);
    
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('stage'), antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);

    // Iluminación Dinámica
    const mainLight = new THREE.PointLight(0x00f3ff, 5, 50);
    scene.add(mainLight);
    scene.add(new THREE.AmbientLight(0x101020, 1));

    // Nave del Jugador (Diseño Geométrico Avanzado)
    const shipGroup = new THREE.Group();
    const bodyGeo = new THREE.ConeGeometry(0.8, 3, 3);
    const bodyMat = new THREE.MeshPhongMaterial({ color: 0x00f3ff, wireframe: true, emissive: 0x00f3ff, emissiveIntensity: 0.5 });
    const shipBody = new THREE.Mesh(bodyGeo, bodyMat);
    shipBody.rotation.x = Math.PI / 2;
    shipGroup.add(shipBody);

    const wingGeo = new THREE.BoxGeometry(4, 0.1, 1);
    const wing = new THREE.Mesh(wingGeo, bodyMat);
    wing.position.z = 0.5;
    shipGroup.add(wing);
    
    scene.add(shipGroup);

    // Entorno: Túnel Infinito
    const tunnelGeo = new THREE.CylinderGeometry(40, 40, 500, 32, 20, true);
    const tunnelMat = new THREE.MeshPhongMaterial({ color: 0x002233, wireframe: true, side: THREE.BackSide, transparent: true, opacity: 0.2 });
    const tunnel = new THREE.Mesh(tunnelGeo, tunnelMat);
    tunnel.rotation.x = Math.PI / 2;
    scene.add(tunnel);

    const objects = { enemies: [], bullets: [], particles: [] };

    function createExplosion(pos, color = 0x00f3ff) {
        for(let i=0; i<20; i++) {
            const p = new THREE.Mesh(new THREE.BoxGeometry(0.2,0.2,0.2), new THREE.MeshBasicMaterial({color: color}));
            p.position.copy(pos);
            p.userData = { 
                v: new THREE.Vector3((Math.random()-0.5)*0.8, (Math.random()-0.5)*0.8, (Math.random()-0.5)*0.8),
                life: 1.0
            };
            scene.add(p);
            objects.particles.push(p);
        }
    }

    function spawnEnemy() {
        const isAnomaly = Math.random() > 0.8;
        const geo = isAnomaly ? new THREE.TorusKnotGeometry(1, 0.3, 64, 8) : new THREE.OctahedronGeometry(1.5, 0);
        const mat = new THREE.MeshPhongMaterial({ 
            color: isAnomaly ? 0xff00ff : 0xff3c00, 
            wireframe: true,
            emissive: isAnomaly ? 0xff00ff : 0xff3c00,
            emissiveIntensity: 0.8
        });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.set((Math.random()-0.5)*50, (Math.random()-0.5)*40, -150);
        mesh.userData = { type: isAnomaly ? 'boss' : 'grunt', rot: Math.random()*0.1 };
        scene.add(mesh);
        objects.enemies.push(mesh);
    }

    function fire() {
        // GEOMETRÍA DEL PROYECTIL
        const b = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 2, 8), new THREE.MeshBasicMaterial({color: 0xffffff}));
        
        // ORIGEN: Ligeramente debajo de la perspectiva de la cámara (Efecto Cockpit)
        const origin = new THREE.Vector3(shipGroup.position.x, shipGroup.position.y - 4, camera.position.z - 2);
        b.position.copy(origin);
        
        // OBJETIVO: Donde la nave (retícula) está apuntando actualmente en el plano Z=0, pero proyectado al fondo
        const target = new THREE.Vector3(shipGroup.position.x, shipGroup.position.y, -200);
        
        // CÁLCULO DE TRAYECTORIA CONVERGENTE
        const direction = new THREE.Vector3().subVectors(target, origin).normalize();
        b.userData.velocity = direction.multiplyScalar(5); // Velocidad del pulso
        
        // ALINEAR EL PROYECTIL CON LA DIRECCIÓN
        b.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), direction);

        scene.add(b);
        objects.bullets.push(b);
        
        // Audio Synth táctico
        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        const o = ctx.createOscillator();
        const g = ctx.createGain();
        o.type = 'square';
        o.frequency.setValueAtTime(523, ctx.currentTime);
        o.frequency.exponentialRampToValueAtTime(40, ctx.currentTime + 0.1);
        g.gain.setValueAtTime(0.04, ctx.currentTime);
        o.connect(g); g.connect(ctx.destination);
        o.start(); o.stop(ctx.currentTime + 0.1);
    }

    // --- VISION ENGINE (MEDIAPIPE) ---
    const handState = { x: 0, y: 0, isFist: false, active: false };
    const smoothPos = { x: 0, y: 0 };
    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.8 });

    hands.onResults((res) => {
        if (res.multiHandLandmarks && res.multiHandLandmarks.length > 0) {
            handState.active = true;
            const lm = res.multiHandLandmarks[0];
            handState.x = (lm[9].x - 0.5) * -120;
            handState.y = (lm[9].y - 0.5) * -80;
            const dist = [8,12,16,20].reduce((a, t) => a + Math.hypot(lm[t].x - lm[0].x, lm[t].y - lm[0].y), 0) / 4;
            handState.isFist = dist < 0.22;
        } else { handState.active = false; }
    });

    const cam = new Camera(document.getElementById('input_video'), {
        onFrame: async () => { await hands.send({image: document.getElementById('input_video')}); },
        width: 640, height: 480
    });
    cam.start();

    // --- LOOP DE JUEGO ---
    let lastFire = 0;

    function animate() {
        requestAnimationFrame(animate);
        
        if (!active) {
            renderer.render(scene, camera);
            return;
        }

        // Navegación y Apuntado
        if (handState.active) {
            smoothPos.x += (handState.x - smoothPos.x) * 0.12;
            smoothPos.y += (handState.y - smoothPos.y) * 0.12;
            shipGroup.position.set(smoothPos.x, smoothPos.y, 0);
            
            // Inclinación dinámica de la nave
            shipGroup.rotation.z = (smoothPos.x / 60) * 1.2;
            shipGroup.rotation.y = -(smoothPos.x / 60) * 0.5;
            
            mainLight.position.set(smoothPos.x, smoothPos.y, 5);

            const ret = document.getElementById('reticle');
            ret.style.left = `${(1 - (handState.x / -120 + 0.5)) * window.innerWidth}px`;
            ret.style.top = `${(handState.y / -80 + 0.5) * window.innerHeight}px`;
            ret.className = handState.isFist ? 'fist' : '';

            if (handState.isFist && Date.now() - lastFire > 180) {
                fire();
                lastFire = Date.now();
            }
        }

        // Proyectiles con trayectoria vectorial
        for (let i = objects.bullets.length - 1; i >= 0; i--) {
            const b = objects.bullets[i];
            b.position.add(b.userData.velocity);
            if (b.position.z < -250) { scene.remove(b); objects.bullets.splice(i, 1); }
        }

        // Enemigos
        if (Math.random() < config.spawnRate) spawnEnemy();
        for (let i = objects.enemies.length - 1; i >= 0; i--) {
            const e = objects.enemies[i];
            e.position.z += config.speed + (stats.level * 0.2);
            e.rotation.x += e.userData.rot;
            
            // Colisión con balas tácticas
            objects.bullets.forEach((b, bi) => {
                if (b.position.distanceTo(e.position) < 2.8) {
                    createExplosion(e.position, e.userData.type === 'boss' ? 0xff00ff : 0xff3c00);
                    scene.remove(e); objects.enemies.splice(i, 1);
                    scene.remove(b); objects.bullets.splice(bi, 1);
                    stats.score += e.userData.type === 'boss' ? 500 : 100;
                    stats.combo++;
                    if(stats.combo > 10) {
                        document.getElementById('combo-msg').style.opacity = 1;
                        setTimeout(() => document.getElementById('combo-msg').style.opacity = 0, 1000);
                    }
                    if(stats.score % 3000 === 0) stats.level++;
                }
            });

            // Colisión con estructura del jugador
            if (e && e.position.distanceTo(shipGroup.position) < 2.5) {
                stats.health -= 15;
                stats.combo = 0;
                createExplosion(shipGroup.position, 0xffffff);
                scene.remove(e); objects.enemies.splice(i, 1);
                if (stats.health <= 0) endGame();
            }

            if (e && e.position.z > 20) { scene.remove(e); objects.enemies.splice(i, 1); }
        }

        // Partículas
        for (let i = objects.particles.length - 1; i >= 0; i--) {
            const p = objects.particles[i];
            p.position.add(p.userData.v);
            p.userData.life -= 0.02;
            p.material.opacity = p.userData.life;
            if (p.userData.life <= 0) { scene.remove(p); objects.particles.splice(i, 1); }
        }

        // Renderizado del Vacío
        tunnel.rotation.y += 0.002;
        tunnel.position.z = (tunnel.position.z + 2) % 100;

        document.getElementById('score').innerText = stats.score.toString().padStart(5, '0');
        document.getElementById('health').innerText = Math.max(0, stats.health) + "%";

        camera.position.z = 20;
        renderer.render(scene, camera);
    }

    function endGame() {
        active = false;
        const ov = document.getElementById('overlay');
        ov.style.display = 'flex';
        ov.innerHTML = `<h1 style="color:var(--red); font-size:3rem;">NEURAL SYNC LOST</h1><p>INTEGRIDAD DEL NÚCLEO: 0%</p><p>PUNTUACIÓN FINAL: ${stats.score}</p><button class="btn-core" onclick="location.reload()">REINICIAR INTERFAZ</button>`;
    }

    document.getElementById('init-btn').addEventListener('click', () => {
        active = true;
        document.getElementById('overlay').style.display = 'none';
    });

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();
</script>
</body>
</html>
